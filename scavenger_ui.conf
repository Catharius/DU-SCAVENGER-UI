# This is a file describing a standard autoconfiguration, do not edit.
# See custom/sample.conf for a more generic template and explanation on the syntax.

name: scavenger_ui

slots:
    core:
        class: CoreUnit
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual

handlers:
    library:
        start:
            lua: |
                -- Configuration variables
                ship_align_angle = 90 --export: Target angle to maintain
                bookmark_range_alert_distance = 7500 --export: Distance in meter, if a bookmark is closer than this it will be shown with the "in range" color 
                bookmark_in_range_color = "0FFF67" --export: Bookmark color when the bookmark is in range
                bookmark_outof_range_color = "bf5f00" --export: Bookmark color when the bookmark is not in range
                alignment_precision = 0.3 --export: Number in degrees, for example if your chosen angle is 90Â° the autopilot will stop aligning between 90-theprecision and 90+theprecision
                alignment_strength = 2 --export: Force applied to align, tweak this with caution, if too big it will make your ship spin
                maintain_altitude = true --export: Maintain altitude or no

                -- Functions
                function split(s, delimiter)
                    result = {}
                    for match in (s..delimiter):gmatch("(.-)"..delimiter) do
                        table.insert(result, match);
                    end
                    return result
                end

                function getDistanceDisplayString(distance)
                    local su = distance > 100000
                    local result = ""
                    if su then
                        -- Convert to SU
                        result = round(distance / 1000 / 200, 1) .. " SU"
                    elseif distance < 1000 then
                        result = round(distance, 1) .. " M"
                    else
                        -- Convert to KM
                        result = round(distance / 1000, 1) .. " KM"
                    end

                    return result
                end

                function round(num, numDecimalPlaces)
                    return tonumber(string.format("%." .. (numDecimalPlaces or 0) .. "f", num))
                end

                function sortSlot()
                    for key, slot in pairs(unit) do
                        if type(slot) == "table" and type(slot.export) == "table" then
                            if slot.getElementIdList then
                                core = slot
                            elseif slot.setHTML then
                                screen = slot
                            elseif slot.getKeys then    
                                databank = slot    
                            end
                        end
                    end
                end

                -- code provided by tomisunlucky
                -- Will give the ship heading in degree
                function getHeading(forward)   
                    local up = -vec3(core.getWorldVertical())
                    forward = forward - forward:project_on(up)
                    local north = vec3(0, 0, 1)
                    north = north - north:project_on(up)
                    local east = north:cross(up)
                    local angle = north:angle_between(forward) * constants.rad2deg
                    if forward:dot(east) < 0 then
                        angle = 360-angle
                    end
                    return angle
                end

                function computeBookmarkAge(bookmarkkey)
                    local formated_time=""
                    if bookmarkkey then
                        local age = (system.getTime()-bookmarkkey)
                        -- DAYS (86 400 seconds are one day)
                        local days = age // 86400
                        -- Modulus to get hours lefts
                        age = age % 86400
                        -- HOURS (3600 seconds are one hour)
                        local hours = age // 3600
                        -- Modulus again to get minutes lefts
                        age = age % 3600
                        -- MINUTES (60 seconds are 1 minute) 
                        local minutes = age // 60
                        -- Modulus again to get minutes lefts
                        age = age % 60
                        local seconds = age
                        if days > 0 then
                            formated_time = tonumber(string.format("%."..(0).."f",days)).."d:"..tonumber(string.format("%."..(0).."f",hours)).."h:"..tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"  
                        elseif hours>0 then
                            formated_time = tonumber(string.format("%."..(0).."f",hours)).."h:"..tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"         
                        elseif minutes>0 then
                            formated_time = tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"            
                        elseif seconds>0 then
                            formated_time = tonumber(string.format("%."..(0).."f",minutes)).."m:"..tonumber(string.format("%."..(0).."f", seconds)).."s"                
                        end        	 
                    end
                    return formated_time
                end
    unit:
        tick:
            args: [showzone]
            lua: |
                local closest_scan_distance = -1
                local totalbm = 0
                local closestBookmark = nil

                -- First we are going to check every bookmarks in the databank
                -- For every one of them we are computing the ship s distance to them 
                -- We keed the closest one in the end
                for _, key in ipairs(json.decode(databank.getKeys())) do
                    totalbm = totalbm + 1 --Counting nb of bookmarks
                    local data = databank.getStringValue(key)
                    data = split(data,"|")
                    scan_position = vec3({tonumber(data[1]),tonumber(data[2]),tonumber(data[3])})
                    local distanceToScan = (scan_position - vec3(core.getConstructWorldPos())):len()
                    if closest_scan_distance < 0 then
                        closest_scan_distance = distanceToScan
                        closestBookmark = key
                    elseif  closest_scan_distance > distanceToScan then
                        closest_scan_distance = distanceToScan
                        closestBookmark = key
                    end 
                end

                -- Change bookmark if necessary (Used to avoid making a setDestination at every tick)
                if currentBookmark == nil and closestBookmark ~= nil then
                    -- Executed once if there is no bookmarks in the databank
                    currentBookmark = closestBookmark
                    currentBookmarkData = databank.getStringValue(currentBookmark)
                    currentBookmarkData = split(currentBookmarkData,"|")
                    worldCoords = current_planet:convertToMapPosition(vec3({tonumber(currentBookmarkData[1]),tonumber(currentBookmarkData[2]),tonumber(currentBookmarkData[3])}))
                    system.setWaypoint([[::pos{0,]]..current_planet_id..[[,]]..worldCoords.latitude*constants.rad2deg..[[,]]..worldCoords.longitude*constants.rad2deg..[[,]]..worldCoords.altitude..[[}]])
                elseif currentBookmark ~= closestBookmark then
                    -- Executed when we find a bookmark closer than the current one
                    currentBookmark = closestBookmark
                    currentBookmarkData = databank.getStringValue(currentBookmark)
                    currentBookmarkData = split(currentBookmarkData,"|") -- Getting data (We could register more data like radar contacts at the time of the bookmark for example, or fuel level of your ship)
                    -- We are converting raw coordinates into a map coordinate so we can make a setDestination
                    worldCoords = current_planet:convertToMapPosition(vec3({tonumber(currentBookmarkData[1]),tonumber(currentBookmarkData[2]),tonumber(currentBookmarkData[3])}))
                    system.setWaypoint([[::pos{0,]]..current_planet_id..[[,]]..worldCoords.latitude*constants.rad2deg..[[,]]..worldCoords.longitude*constants.rad2deg..[[,]]..worldCoords.altitude..[[}]])
                end    

                -- Experimental automatic mode to put waypoint every x km 
                --if false and closest_scan_distance>bookmark_visited_distance then  
                --    databank.setStringValue(system.getTime(),system.getPlayerWorldPos(unit.getMasterPlayerId())[1].."|"..system.getPlayerWorldPos(unit.getMasterPlayerId())[2].."|"..system.getPlayerWorldPos(unit.getMasterPlayerId())[3])
                --    closest_scan_distance = 0
                --end 

                local color = bookmark_outof_range_color
                if closest_scan_distance<bookmark_range_alert_distance then
                    color = bookmark_in_range_color
                end    

                -- Computing heading angle to show in the HUD
                local angle = getHeading(vec3(core.getConstructWorldOrientationForward()))
                local arrow = ""
                local color_angle = "7f0000"
                if angle>(ship_align_angle-3) and angle <(ship_align_angle+3) then
                    color_angle = "0FFF67"
                elseif angle>(ship_align_angle-10) and angle <(ship_align_angle+10) then
                    color_angle = "ffaa56"
                end    

                local stabmessage = [[<text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="603.15785" x="1126.68424" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">Turn the ship slowly to the green zone</text>]]
                if stabilizeShip and angle>(ship_align_angle-5) and angle<(ship_align_angle+5) then
                    stabmessage = [[<text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="603.15785" x="1126.68424" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#0FFF67">Aligned</text>]]
                elseif not stabilizeShip and angle>(ship_align_angle-5) and angle<(ship_align_angle+5) then     
                    stabmessage = [[<text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="603.15785" x="1126.68424" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">Press Alt+1 to align</text>]]     
                end

                -- We make an arrow that moves from 0Â° to 360Â°
                arrow = [[<g transform="translate(]]..angle..[[,0)">
                <path transform="rotate(-90, 758.757, 611.145)" id="svg_7" d="m760.19621,611.14456l-8.44388,-10.80688l5.56096,0l8.44388,10.80688l-8.44388,10.80687l-5.56096,0l8.44388,-10.80687z" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#7f0000"/>
                <path transform="rotate(90, 758.757, 584.479)" id="svg_8" d="m760.19621,584.47789l-8.44388,-10.80688l5.56096,0l8.44388,10.80688l-8.44388,10.80687l-5.56096,0l8.44388,-10.80687z" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#7f0000"/>
                <rect id="svg_10" height="10" width="2" y="592.89475" x="757.71946" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#7f0000"/>
                </g>]]  

                --Show HUD
                system.setScreen([[<svg style="position:absolute;top:0vh" viewBox="0 0 1920 1080" style="width:100%; height:100%">
                    <g transform="translate(0,-435)">
                    <g>
                    <rect id="svg_3" height="10" width="360" y="592.89475" x="758" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#ffaa56"/>
                    <g transform="translate(]]..ship_align_angle..[[,0)"><rect id="svg_5" height="10" width="10" y="592.69475" x="754" stroke-opacity="null" stroke-width="1.5" stroke="#000" fill="#7fff00"/></g>
                    ]]..arrow..[[
                    <g transform="translate(0,0)"><text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="590.69475" x="754" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">N</text></g>
                    <g transform="translate(90,0)"><text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="590.69475" x="754" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">E</text></g>
                    <g transform="translate(180,0)"><text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="590.69475" x="754" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">S</text></g>
                    <g transform="translate(270,0)"><text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="590.69475" x="754" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">W</text></g>
                    <g transform="translate(360,0)"><text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="590.69475" x="754" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">N</text></g>
                    <text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="18" id="svg_12" y="570.5264" x="917.89381" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#]]..color_angle..[[">]]..round(angle,2)..[[Â°</text>
                    <text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_13" y="641.10522" x="810.84214" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">Nearest bookmark (created ]]..computeBookmarkAge(closestBookmark)..[[ ago)</text>
                    <text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="18" id="svg_13" y="662.10522" x="913.84214" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#]]..color..[[">]]..getDistanceDisplayString(closest_scan_distance)..[[</text>
                    <text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_14" y="603.15785" x="683.68424" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">]]..totalbm..[[/350</text>
                    <text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="15" id="svg_15" y="617.15785" x="683.68424" stroke-opacity="null" stroke-width="0" stroke="#000" fill="#ffffff">Bookmarks</text>]]..stabmessage..[[
                    </g></g></svg>]])
        start:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                brakeInput = 0

                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)

                -- element widgets
                -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
                _autoconf.displayCategoryPanel(weapon, weapon_size, L_TEXT("ui_lua_widget_weapon", "Weapons"), "weapon", true)
                core.show()
                _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_periscope", "Periscope"), "periscope")
                placeRadar = true
                if atmofueltank_size > 0 then
                    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, L_TEXT("ui_lua_widget_atmofuel", "Atmo Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                if spacefueltank_size > 0 then
                    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, L_TEXT("ui_lua_widget_spacefuel", "Space Fuel"), "fuel_container")
                    if placeRadar then
                        _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                        placeRadar = false
                    end
                end
                _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, L_TEXT("ui_lua_widget_rocketfuel", "Rocket Fuel"), "fuel_container")
                if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
                    _autoconf.displayCategoryPanel(radar, radar_size, L_TEXT("ui_lua_widget_radar", "Radar"), "radar")
                    placeRadar = false
                end
                if antigrav ~= nil then antigrav.show() end
                if warpdrive ~= nil then warpdrive.show() end
                if gyro ~= nil then gyro.show() end

                -- freeze the player in he is remote controlling the construct
                if Nav.control.isRemoteControlled() == 1 then
                    system.freeze(1)
                end

                -- landing gear
                -- make sure every gears are synchonized with the first
                gearExtended = (Nav.control.isAnyLandingGearExtended() == 1) -- make sure it's a lua boolean
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

                --Init
                vec3  = require('cpml.vec3')
                utils = require('cpml.utils')
                planetRef = require('cpml.planetref')
                referenceTableSource = require('cpml.atlas')
                galaxyReference = planetRef(referenceTableSource)
                helios = galaxyReference[0]
                currentBookmark = nil
                current_planet_id = 2
                current_planet = helios[current_planet_id] -- See atlas for ref

                databank = nil
                screen = nil
                -- Init slots
                sortSlot()
                -- if databank is null print error
                if databank == nil then
                    system.setScreen([[<svg style="position:absolute;top:0vh" viewBox="0 0 1920 1080" style="width:100%; height:100%">
                    <g>
                    <text xml:space="preserve" text-anchor="start" font-family="sans-serif" font-size="24" id="svg_1" y="548.5" x="571.29999" stroke-width="0" stroke="#000" fill="#bf0000">NO DATABANK FOUND, PLEASE LINK A DATABANK TO YOUR SEAT</text>
                    </g>
                </svg>]])
                else     
                    -- Init state
                    unit.setTimer("showzone",0.25)
                    stabilizeShip=false
                    TargetAltitude = 0
                    -- Visuals 
                    core.hide()
                end
                system.showScreen(1)
        stop:
            lua: |
                _autoconf.hideCategoryPanels()
                if antigrav ~= nil then antigrav.hide() end
                if warpdrive ~= nil then warpdrive.hide() end
                if gyro ~= nil then gyro.hide() end
                core.hide()
                Nav.control.switchOffHeadlights()

    system:
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(core.getConstructWorldOrientationUp())
                local constructForward = vec3(core.getConstructWorldOrientationForward())
                local constructRight = vec3(core.getConstructWorldOrientationRight())
                local constructVelocity = vec3(core.getWorldVelocity())
                local constructVelocityDir = vec3(core.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- FoolsFolly autopitch
                if stabilizeShip==true and maintain_altitude==true then
                    local currentPitchDeg = math.max(math.min(getRoll(worldVertical, constructRight, -constructForward)/60, 1), -1) -- Angle of construct's current pitch, expressed as a value between -1 and 1, up to 60 degrees
                    local heightDiff = math.max(math.min((TargetAltitude - core.getAltitude())/1000, 1), -1) -- Difference between current and target altitude; values expressed between -1 and 1, up to 1000m
                    local verticalSpeed = vec3(core.getWorldVelocity()):dot(-vec3(core.getWorldVertical()))*3.6/2500 -- Speed moving up/down, in km/h, divided by 1000
                    finalPitchInput = (heightDiff - currentPitchDeg) - verticalSpeed -- Increase pitch relative to needed altitude change, decrease relative to current pitch, decrease relative to current vertical speed
                end

                -- Rotation
                local constructAngularVelocity = vec3(core.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp
                                                
                -- START OF SCAVENGER SCRIPT CODE
                if stabilizeShip==true then
                    local targetRollDeg = utils.clamp(0, currentRollDegAbs - 30, currentRollDegAbs + 30); -- we go back to 0 within a certain limit
                    if (rollPID == nil) then
                        rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                    end
                    rollPID:inject(targetRollDeg - currentRollDeg)
                    local autoRollInput = rollPID:get()
                    targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    -- align script
                    local angle = getHeading(vec3(core.getConstructWorldOrientationForward()))
                    if angle>(ship_align_angle-5) and angle<(ship_align_angle+5) then
                        if angle<ship_align_angle-alignment_precision then
                            --Turn right very slowly
                            yawInput = yawInput - (alignment_strength/1000)  
                        elseif angle>ship_align_angle+alignment_precision then
                            --Turn left very slowly
                            yawInput = yawInput + (alignment_strength/1000)
                        else
                            --We are aligned, no need to turn anymore
                            yawInput = 0
                        end    
                    end
                end      
                -- END OF SCAVENGER SCRIPT CODE

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don t go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(core.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        update:
            lua: Nav:update()
        inputText:
            args: [exportdb]
            lua: |
                if screen == nil then
                    system.print("Link a screen to your seat first and type restoredb again")
                else
                    unit.stopTimer("showzone")
                    local html =
                        "-- Copy this in a notepad or a text editor, copy paste in system/inputText(restoredb) and type restoredb to load this data into the databank\r\n"
                    for _, key in ipairs(json.decode(databank.getKeys())) do
                        local data = databank.getStringValue(key)
                        data = split(data, "|")
                        html = html .. [[databank.setStringValue("]] .. key .. [[","]] ..
                                data[1] .. [[|]] .. data[2] .. [[|]] .. data[3] .. [[")]] .. "\r\n"
                    end
                    screen.activate()
                    screen.setHTML(html)
                    system.print(
                        "DATA EXPORTED, right click on the screen, advanced/edit html content to view data")
                    unit.setTimer("showzone", 1)
                end
        inputText:
            args: [restoredb]
            lua: |
                 -- Copy paste here the exported commands and type restoreddb in the lua console  
        inputText:
            args: [resetdb]
            lua: |
                -- Copy paste here the exported commands and type restoreddb in the lua console
                databank.clear()
                system.print("DATABANK HAS BEEN RESET")          
        actionStart:
            args: [option1]
            lua: |
                -- Activate auto align
                if stabilizeShip==true then
                    stabilizeShip = false
                else
                    stabilizeShip = true
                    TargetAltitude = core.getAltitude()--We take the current one
                end    
                -- restore yaw to zero
                yawInput = 0
        actionStart:
            args: [option2]
            lua: |
                -- Save a bookmark into the database
                databank.setStringValue(system.getTime(),system.getPlayerWorldPos(unit.getMasterPlayerId())[1].."|"..system.getPlayerWorldPos(unit.getMasterPlayerId())[2].."|"..system.getPlayerWorldPos(unit.getMasterPlayerId())[3])            
        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: |
                if stabilizeShip==true then
                    stabilizeShip = false
                    -- restore yaw to zero
                    yawInput = 0
                end 
                yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: |
                if stabilizeShip==true then
                    stabilizeShip = false
                    -- restore yaw to zero
                    yawInput = 0
                end    
                yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                brakeInput = brakeInput + 1
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: brakeInput = brakeInput - 1

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end